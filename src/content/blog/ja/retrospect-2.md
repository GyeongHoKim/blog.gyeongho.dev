---
title: '私が会社に貢献したこと'
description: '2024年振り返り'
pubDate: 'Jan 2 2025'
heroImage: '../../../assets/images/fox.png'
category: 'Frontend'
tags: ['Career', 'Retrospect', 'Improvement']
lang: 'ja'
---

# ウェブ開発者：ウェブ開発でビジネス価値を創出するか問題を解決する人

入社当時、私たちの部署にはウェブ開発者がいませんでした。[このような様々な問題を経験し](https://blog.gyeongho.dev/post/retrospect-1/)、私はウェブ開発者になることにしました。

> 私が貢献したことは何か、そして私が貢献すべきことは何か？

- 会社が私を採用した理由

私たちの製品はWindows Applicationです。それにもかかわらずウェブを導入した理由は、生産性とデザインの一貫性です。したがって、私は低い生産性と一貫性のないデザインを解決するために、この席に座っていることになります。2つの分野で、2024年に私が貢献したことを整理してみましょう。

# 生産性の改善

1. 開発およびデバッグ環境の改善

- 問題

開発環境の場合、前任者たちは自分が開発するWEBが動作するか確認するために、C++バックエンドサーバーをビルドする必要がありました。C++ビルドエラーが発生すると、ウェブフロントエンド開発が停止します。PostManなどのツールの使い方を知らないため、C++開発者がAPIを作成するまで、想像しながら開発していました。

- 解決法

開発中はVite開発サーバーとMSW、ユニットテストの場合はvitestでモックし、[E2Eテスト](https://blog.gyeongho.dev/post/frontend-test-1/)はCypressで解決しました。デバッグはvscodeとJetBrains製品の設定ファイルで統一しました。

現在に至り、バックエンドサーバーのビルドが失敗したためにフロントエンド開発が停止する事態は、もはや発生しません。

2. タスク自動化ツールの使用

- 問題

前任者はライブラリを使用するためにフォルダをコピー&ペーストする必要があり、デプロイのために、すべてのソースコードをindex.htmlとindex.jsに手動で含める作業をしていました。

- 解決法

Lernaを利用してモノレポ構造を作成し、私が開発したデザインシステムとWeb Componentルーターライブラリはworkspaceを通じて参照します。
ビルドスクリプトを作成しました。初期にはParcelと直接作成したプラグインを利用してGruntでスクリプトを作成し自動化し、TypeScriptマイグレーションを進めた後、現在のappはviteで、ライブラリはtsupを使用します。

3. ライブラリ使用の改善

- 問題

まずモジュールシステムがなく（AMD、CJS、ESM）、前任者たちがオープンソースライブラリを使用するためにminifyされたjsを直接ダウンロードして、どこかに保存し、ランタイムに動的に挿入するようにして退職したため、新しく入社した前任者はそれをJavaScriptの基本メソッドだと思い込んで使用します。当時のウェブサービスは、ユーザーが1人だけ接続してもトラフィックがスパイクし、ウェブサーバーが応答さえしなくなったため、外部ライブラリを挿入するそのファイルが応答する際にサーバーがクラッシュすると動作しません。

- 解決法

当時、同じファイルを複数回リクエストするか、ウェブサーバーのパフォーマンスを最適化してしまう奇想天外な方法を選択していました。私の解決法は簡単でした。単にサーバーに不要なファイル数百個をリクエストしないことです。tree shakingを実装しましょう。

4. コードスタイルの強制

- 問題

冗談半分で聞いた話では、当時の前任者の気分に応じて2 spaceを使用するか4 spaceを使用するかが決まっていたとのことです。C++の場合はgoogle styleを使用するように文書までありましたが、JavaScriptには別途ありませんでした。

- 解決法

ESLintとHuskyを使用して、規則に従わない場合はコミットができないようにブロックしました。

私がバックエンドメディアサーバーを開発していた頃、当時のフロントエンド開発者がESLintに従わないとコミットができないのを見て、私を変な目で見ていた記憶があります。

おそらく私の後任となる開発者も同じ理由で私を嫌うでしょうが、自分が本当に規則を守ったかどうか考えてみてほしいと思います。

5. ドキュメント作成

- 問題

ドキュメントがありません。パラメータに何が入るのか分からず、前任者たちも古代に作成されたグローバル関数にどのパラメータが入るのか、ランタイムに何で上書きされるのかを知らないため、自分の前任者のコードをコピー&ペーストしていたため、後で私が分析した結果、2世代前の前任者が誤って作成したコードにより悪循環の連鎖が生じた場合がありました。

- 解決法

少なくとも私が作成した関数とクラスにはJSDocを記述しました。現在はTypeScriptにマイグレーションしたため、ランタイムにエラーが発生するのではなく、ビルド時点でエラーが発生します。

現在に至り、私が開発したすべてのライブラリとデザインシステムは、IDEのSyntax機能を有効にしてもすべての行に赤線を引かないため、私の後任となる開発者は今安心してIDEのすべての機能を活用でき、開発中に赤線が引かれたら、自分がコードを誤って記述したことに気づくことができます。

# 一貫したデザインの確立

1. デザインシステムの開発

- 問題

前任者たちは類似のUIがあってもCompositionではなくInheritを選択しました。ReactやVue、Angularのようにコンポーネント単位で再利用せず、同じ機能を異なる方法で繰り返し使用していました。

- 解決法

既存のレガシーを捨てることはできず、また他の開発者がどのフレームワークを選択するか分からないため、Web Componentを利用してコンポーネント単位で再利用しました。現在はデザインシステムはWeb Componentで、それを使用する各AppはReactで開発しています。

2. CSS管理の改善

- 問題

前任者の場合、jQueryを利用して自分が望むファイルにCSSをランタイムに注入する方式を使用していました。特定のUIを修正するためにどのファイルを修正すべきかを見つけることが事実上不可能なため、主に`!important`を利用して強制的に上書きする方式を選択していました。

- 解決法

既存のCSSも維持する必要があったため、ShadowDOMを選択しました。後述しますが、現在は生産性のためにShadowDOMを放棄しています。ClassベースのVariantsとShadowDOMは、残念ながら両立不可能であるか、バンドルサイズを犠牲にする必要があります。

3. Storybookの使用

- 問題

主にhtmlはマークアップ、jsはロジック、cssはスタイルを担当する形式であるべきですが、残念ながら当時の前任者はウェブ開発者ではないため、index.jsにjQueryまたはDOM APIを使用してマークアップ+ロジック+スタイルをすべて結合させ、UIだけを表示することが不可能でした。

- 解決法

退職者のPCを受け取り、Storybookサーバーを作成し、私が開発したデザインシステムのStoryを起動しました。デザインシステムの各コンポーネントはロジックがなく、UIのみを担当します。

4. 視覚的回帰テストの導入

[以前のポスト](https://blog.gyeongho.dev/post/frontend-test-2/)を参照してください。

# 要約

1. モノレポおよびビルドプロセスの構築
2. デザインシステムの開発
3. 自社バックエンドサーバーで使用可能なルーターライブラリの開発
4. 自社ウェブクライアントで使用可能なhttp-clientライブラリの開発
5. RTSP -> WebRTC、HLSメディアサーバーの開発
6. 上記のデザインシステム、ルーターなどを使用するWeb APPの開発
