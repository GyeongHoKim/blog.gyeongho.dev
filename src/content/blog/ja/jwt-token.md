---
title: 'Digest認証とユーザー体験の改善'
description: 'JWTトークンを使用することになった背景'
pubDate: 'Dec 8 2024'
heroImage: '../../../assets/images/rabbit.webp'
category: 'Frontend'
tags: ['authentication', 'jwt']
lang: 'ja'
---

# 製品の背景

私たちの製品は、当初ウェブ事業を想定して出発した製品ではありません。IP CameraまたはNVR、DVRとの通信を想定しているため、通信方式の主流はONVIFとRTCP/RTSPであり、HTTP通信は少数派です。IPカメラはHTTP通信を行いますが、市場に出ている（私が見た）すべての製品はDigest認証方式を使用しています。私たちのVMSの場合、ブラウザを通じて使用するのではなく、Windows APP上にCEFを載せて使用しています。多くのAPIは依然としてカスタムプロトコルを使用して、ネットワークを経由せずに自社クライアントと通信します。当然、Digest認証を使用します。

# 問題の把握

私たちのボスが自社クライアントへの依存性を低くしたいと言いました。  
そして今年、ついにウェブ事業の中で**ブラウザ**を通じて私たちの製品を使用するユースケースが生まれ、以下のような状況が発生しました。

> 数分経つと、ブラウザでログインウィンドウが繰り返し表示されます。

私たちがDigest認証を使用しているため、発生した問題です。

# Digest認証の簡単な説明

ダイジェスト認証もウェブ標準です。基本的に、ダイジェスト認証方式はCHFを利用してDigestを生成し、平文送信を防ぐ方式です。通信の過程は以下の通りです。

1. クライアントがサーバーにリクエストを送信する。
2. サーバーは401 Unauthorizedを送信するが、ヘッダーにrealm、nonce、algorithm、qopを含める。
3. クライアントは上記の値を基にcnonceとdigestを計算し、これを含めて再度リクエストを送信する。
4. サーバーはdigest検証後、repauthを含む応答を送信する。

## データベースを使用しない

この認証方式では、サーバー側はハッシュ値を計算した後、その値をファイルとして保存します。そして、ファイルアクセスはネットワークを経由しないため、データベース使用よりも相対的に高速です。

## stateless

nonceが重要ですが、nonceはリプレイ攻撃を防ぐためにサーバーが各リクエストごとに生成する値です。基本的に、Digest認証はstatelessであり、各リクエストごとに上記の過程を繰り返す必要があります。

# ユーザー体験

現代のブラウザは、Networkを通じて入ってくるすべてのリクエストをインターセプトします。そして、Authorizationヘッダー、特にDigest認証に使用されるヘッダーに遭遇すると、**UIスレッドをブロックします**。Digest認証は各リクエストごとに新しいNonceを生成するため、以下のような状況が発生します。

1. ユーザーが特定のボタンを押したが、これがサーバー側に合計3回リクエストを送信する。
2. ブラウザはUIスレッドをブロックし、ユーザーにusername、passwordを要求する。
3. リクエストは成功したが、2番目のリクエストは既に非同期で送信されているため、コンポーネント再レンダリング後に2番目の応答が到着すると：
4. ブラウザはUIスレッドをブロックし、ユーザーにusername、passwordを要求する。
5. リクエストは成功したが...（同じこと）
6. （同じこと）

ユーザー体験は最悪です。特に、WebAPP起動時に最初に受信するリクエストにより、初期読み込みスコアが低くなります。UIスレッドをブロックすると、ユーザーは画面で見られるものが何もなく、ログインを約3回行うだけです。

# セッションを使用せず、JWTトークン方式を使用した理由

もちろん、私たちは基本的にデータベースを使用しませんが、ユーザーにデータベースを構築してもらうよう通知すれば、ユーザー側でデータベースを構築し、私たちの製品に接続する形でデータベースを使用することは可能です。そのため、セッション方式とJWTトークン認証方式の両方で、データベースは問題になりませんでした。  
では、どちらの方式を使用するかについて決定が必要ですが、セッションとJWTトークン方式の両方に長所と短所があります。セッションはすべてのリクエストに対してデータベースにアクセスするため、パフォーマンスが低下し、JWTはトークンの保存主体がクライアントであるため、セキュリティ上の懸念があり、などなど...

私たちもそのような長所と短所を基に決定したいですが、実際にはそのような理由ではなく、現実的な問題のためにJWTを使用しました。まず、私たちの製品が「ウェブ」というプラットフォームを考慮して作られた製品ではないため、自社フレームワークベースでセッションを実装することは困難であるように見えました。

とにかく、私はバックエンド開発者ではないため、2つの方式の長所と短所に関する情報のみを伝え、最終決定はバックエンド開発者が下しました。結果は、JWTトークン方式を使用することです。

# なぜAuthorizationヘッダーを使用したか

私たちのAccess TokenはAuthorizationヘッダーに含めて送信します。なぜそのようにするかというと...

- 他システムへの配慮

AuthorizationヘッダーはHTTP標準であり、他のシステム（代表的に私が開発するプロキシサーバー）で認証ロジックを処理する際に一貫性を維持できます。

- ブラウザ依存性の除去

デスクトップアプリやモバイルは、ブラウザのようにクッキーという保存空間が存在しません。

# Public Certificateを発行してもらうよう主張した理由

コスト問題と事業の特性などの現実的な理由で受け入れられませんでしたが、基本的な骨子は中間者攻撃への懸念でした。

# なぜクッキーをサーバー側で作成してもらうよう主張したか

バックエンド側の実装が困難なため、却下されましたが、私の主張の原因は以下の通りです。

local storageに保存すると、JavaScriptでアクセス可能なため、XSSやCSRF攻撃に脆弱です。

## クッキーファイルを端末から取り出す方式

私たちの製品のユースケース自体が、1つの端末に複数の工場労働者が接続して使用するものです。そのため、悪意を持った労働者がUSBを持参し、直接クッキーファイルを持ち帰り、そのクッキーファイルに保存されたRefresh Tokenを盗取したらどうするかという質問があった際、私は防げないと答えました（そして内心、すごいと思いました）。XSSやCSRFの論点から外れた話ではないか？という考えもありました。

## 操作されたブラウザの使用

操作されたブラウザの使用とは、それが頻繁に起こるのか？と思われるかもしれませんが、そもそも私たちの製品自体がChromiumベースで直接作成したもので、認証に関連して自動化された認証がバックグラウンドで発生する操作されたブラウザを使用していました。そのため、このような状況を考慮したと推測されます。先ほどの状況と同様ですが、操作されたブラウザの使用は論点から外れています...

# なぜAccess TokenとRefresh Tokenを分離するよう主張したか

これは単にバックエンド開発者の方が他の仕事で忙しくてできなかったのですが、分離するよう主張した原因は以下の通りです。

- JWTの創始者が来ても、トークン盗取は防げない。

トークン盗取は起こり得るものと考え、被害を最小限に抑えるアプローチが正しいです。私たちの製品は非常に長い期間のトークン有効期限を持っていました。トークンが盗取された場合、攻撃者がそのトークンを使って何かを行うことができる時間が長すぎます。

しかし、短く設定すると、既存の問題点を解決できません（ユーザー体験）。それでは、トークンを2つ使用すればよいです。これに関する記事は他の場所にも多くあるため、省略します。

「Access Tokenが盗取された場合、Refresh Tokenも同時に盗取された状況なのに、なぜ分離するのか」という質問もありましたが、以下に説明する2つの点が関連しています。

## すべてのリクエストにAccess TokenとRefresh Tokenを一緒に含めて送信しない

物理的盗取を除くと、結局トークン盗取はネットワークを経由するリクエストに対する盗取です（プロキシ、中間者攻撃など）。  
access tokenは仕方ありませんが、refresh tokenはaccess tokenを再発行するAPIを呼び出す際にのみ送信するようにすることで、相対的に盗取の頻度が低下します。少なくとも、Access Tokenが盗取された時点でRefresh Tokenまで一緒に盗取されるケースは発生しません。

## Refresh Token Rotation

他の開発者がRefresh Tokenに疑問を持った理由の中で最も大きいのは、Refresh Tokenが盗取されると、Access Tokenの無制限の自動販売機と同じで、これをどうするのかということでした。

とりあえず検索した際、最も多く言及される方式は、Refresh Tokenを再発行するAPIを呼び出すたびに、既存のRefresh Tokenを無効化する方式です。そうすると、盗取されたRefresh Tokenは、Access Tokenを再発行する過程でエラーが発生します。最初にAccess tokenを発行する場合はどうするのか？先ほども言ったように、盗取されると考え、被害を最小限に抑える観点から見る必要があります。

# どれだけ我慢する必要があるか

![我慢マン](https://i.namu.wiki/i/1r25tCPAOZR0YtQJhVvnurEZ-k2v-Rj4RrTyC8-L3E_2AA9wjNvmH1RKk6-B8G8ddTzKu4N_0mo4e3bQ5QuBtHjNhrEU6wksdbke-ueqk23i2mojxgliDENsnKrlGL0NjTVormGKsz19lfPxWTXFBQ.webp)

トークンをクライアントに委ねる方式を採用した以上、セキュリティ上のトレードオフは受け入れる必要があります。
