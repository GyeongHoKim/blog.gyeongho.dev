---
title: '製品問題の認識'
description: 'リファクタリングが必要だった理由'
pubDate: 'Nov 9 2024'
heroImage: '../../../assets/images/yonghyun-lee-unsplash.jpg'
category: 'Frontend'
tags: ['Career', 'Retrospect', 'Improvement']
lang: 'ja'
---

# 問題の認識

私たちの製品はWindows Applicationです。ウェブを想定して作られた製品ではありません。フロントエンド開発者がいなかったため、チームの最年少または余剰人員が急いで1〜2日JavaScriptを学んで開発したため、全体的に問題が多くありました。

1. 不要なStatic Fileをサーバーに数百個リクエストしている。しかし、その中で実際に使用されているファイルはわずかです。
2. static fileリクエストが多すぎて、ユーザーが1人だけ接続してもトラフィックがスパイクし、ウェブサーバーが一部のファイルに応答できなくなります。
3. 例外処理がないため、ランタイムエラー発生時にWebApp全体が停止します。If分岐処理でCase-By-Caseに対処するのは限界があり、そのコンテキストを誰も知りません。
4. 動的に作成されるすべてのNodeとその子HTMLElementが破棄されず、Heap Memoryを占有し続けています。
5. イベントリスナーが消えずに累積されるだけです。そのため、数分間検索、初期化などの相互作用を続けると、何かをクリックしても数百個のイベントがBubbleしていました。

# 根本的な原因

1. 簡単に要約すると：
   1. 標準を使用しない、JavaScript構文に従わない。自分だけが知る規則と動作しない構文で、自分だけが知るメソッドを特定のファイルに隠して保存し、ランタイムに挿入します。
   2. その規則と関数は、その人が退職すると誰も見つけられません。
2. すべての変数と関数がグローバルに宣言されています。
   1. しかし、それがかなり多く上書きされます。
   2. `foo(); get(); set(); getset() setget();`のような一般的な命名の関数がそれぞれ数千万個定義されています。すべてグローバルに宣言されているため、その中でどの関数がいつ実行されるかを知る人は既に退職しています。
   3. 同じファイルを2〜3回サーバーにリクエストした後実行してしまう特性により、一部のファイルはすべての変数を`const`で宣言してはいけません。どのファイルがそうなのかは「彼ら」だけが知っています。
3. イベントハンドリング
   1. まず、JavaScriptのEventクラスを使用しません。
   2. イベントハンドラーとHTMLElementは作成されるだけで、破棄されません。
   3. 独自定義のEventクラスはClassNameを利用してCatchを行っており、当然ClassNameは一意ではないため、自分だけが知るClassName規則を作成してClassNameでイベントを区別していますが、その規則を知る唯一の人が退職しました。
   4. イベントを処理するメソッドは、さらにPrototypeを利用したMonkey Patchingを使用して実装します。そのため、すべてのファイルが信頼できず、私がこのイベントを処理するメソッドを`Ctrl + 左クリック`しても何も表示されません。明らかにどこかでMonkey Patchingして、自分だけが知る方法で処理しているため、常にすべてのファイルを徹底的に調査する必要があります。
4. CSSとJavascriptコードをインポートするために、特定の関数でランタイム中にindex.htmlにscriptタグを挿入します。
   1. scriptタグのために反応が遅くなることを懸念して、非同期で取得するという意図はOKです。
   2. しかし、それを初期化プロセスではなく、各スクリプトファイルに分散させており、その基準が存在しないため、一部のスクリプトにはあり、一部のスクリプトにはありません。
   3. そのため、機能動作中にscriptタグを追加する際、既に宣言された変数と名前が重なった場合、既存の意図した動作ではなく別の動作が実行されたり、constによりランタイムエラーが発生したりします。
   4. 例外処理がありません。case by caseで逐一if分岐処理しています。
5. 命名は重要ですが、全体的に混乱しています。例は以下の通りです。
   1. `include_js(), include_css()` `#include <sth.h>`をJSバージョンで作成したものと推測しています。一部のファイルにヘッダーファイルを模倣した痕跡があったためです。
   2. `strlen(), strcpy(), strcat()` バイト単位操作でlengthを取得し、copyし、concatするものを作成しましたが、それを作成する必要はありません。
   3. その他、CのstdioやC++のstringライブラリと同一の命名の多数のグローバル関数がありました。そして、不要または誤って実装したが、偶然意図した動作と一致する関数でした。
   4. メソッド名でgetSet、setGet、getFunc、getFooなどとなっており、意図を理解できません。
6. すべてのグローバル関数は、呼び出し直後にisValid(sth)を呼び出し、その結果をif文で分岐処理していました。
   1. まず、Validの基準を明確に定義していませんでした。
   2. ArrayまたはMapに属する場合はTrueを返します。
   3. 問題は、ArrayでなくてもValidなパラメータであるのに、すべてのグローバル関数に対してこのロジックを適用していたことです。
   4. 退職者の誰かがisValidを作成し、その後に入社した人は、それをJavaScriptの基本メソッドだと思い、原理を知らずに使用していました。
7. すべてのメソッドがMonkey Patchingを通じて作成されており、すべてのファイルが信頼できません。
   1. 特定のクラスのメソッドの使用方法を知るために、多数のファイルを検索する必要があり、私が見ているこのメソッドが実存するメソッドなのか、このファイルでモンキーパッチされたメソッドなのか、またはランタイムに上書きされるメソッドなのか分かりません。
8. CSS管理方式
   1. ボタンに関するCSSがボタンファイルにありません。jQueryとDOM APIを同時に使用していましたが、ボタンCSS操作をTable関連のファイルで行い、Table CSS操作をindex.jsで行います。
   2. 一貫性のない方式：CSS-in-JS、CSSファイル、動的なStyleタグ挿入など、すべての方法を総動員してCSS管理方式を分断しました。
9. 一貫性のないコードスタイル
   1. ES6構文を途中まで使用します。これは、Classを定義しておきながらメソッドはprototypeで追加するという意味です。
   2. 些細な問題ですが、2 spaceと4 spaceを途中まで使用します。ESLintやPrettierのようなツールの存在を知らないため、それは仕方ありません。Visual Studioで開発していましたが、VSにはAuto Format機能があるのではないでしょうか？
10. ライブラリ管理をしていない
    1. libというフォルダがあるため、そこにすべてを集約すると思っていましたが、そうではありません。自分だけが知る特定のフォルダにマルウェアのように隠して保存します。そして退職し、次の人はJavaScriptを1〜2日学んで投入されるため、それをJavaScriptの基本関数だと思い使用することが問題です。
    2. 例えば、`moment()`はmoment.jsという外部ライブラリの関数です。当然、「彼ら」の誰かがmomentを使用するために、プロジェクトフォルダのどこかにmoment.jsをダウンロードして保存し、数百個のファイルのどこかに`include_js('<path>')`を置いて退職したのでしょう。
    3. 実際、date time pickerライブラリとexcel.jsライブラリの場合、それらのライブラリにのみ存在するメソッドを使用しており、それをJavaScriptの基本機能だと思っていました。
11. パッケージマネージャー、バンドリング、ビルドなし。ウェブフレームワークを各プロジェクトフォルダに`CTRL + C`、`CTRL + V`で全体をコピーして使用します。
    1. 少なくともGruntのようなタスク自動化ツールを使用しましょう。ビルドプロセスなどは望みません。少なくともウェブフレームワークを各フォルダに全体をコピーするなら、それくらいは自動化できるはずです。
    2. しないなら、少なくとも各フォルダごとにpackage.jsonに**version**を明記する必要がありますが、各プロジェクトの状態を表現する何かが存在しません。
    3. ビルドプロセス自動化がないため、各プロジェクトごとにウェブフレームワークのバージョンが異なります。つまり、ウェブフレームワークのバージョン管理をしていません。
    4. ウェブフレームワークをどのように取得するか尋ねたところ、その容量の大きなフォルダを全体をコピーして使用するとのことでした。では、Production用にデプロイする際はどうするか尋ねると、コピー&ペーストしてindex.jsを修正するようにとのことでした。これにより、実際にデプロイされたウェブページがその容量の大きなフォルダのすべてのファイルを呼び出すようになり、ページ読み込みに10秒かかるようになりました。

# リファクタリングの進行方向

まず規則を定め、プロセスを確立しました。現在は別のものに変更しましたが、私が最初に投入され、過渡期段階では：

1. 適切なツールを使用して生産性を向上させました。
   - Lerna & Nxを使用してモノレポ構造を作成しました。
   - GruntとParcelを使用したビルドプロセスを作成しました。
   - 退職者のコンピュータを受け取り、そこにNPMレジストリを構築しました。そこには私が作成したデザインシステムライブラリおよびルーターライブラリをデプロイしました。
2. コードスタイルを強制しました。
   - 現在は、以下の規則に従わない場合、ビルドスクリプトが失敗します。
   - ES6構文を使用することにしました。しかし、すぐにレガシーコードも使用する必要があるため：
     - 抽象構文木を解析してGlobal Scope jsをESMに自動変換するツールを直接作成しました。
     - それをオープンソースで作成すれば、本当に多くの人が使用するでしょうが、私たちのチームにはウェブ開発者がおらず、ウェブを扱うチームは当然AMDを使用するため、理解してくれる人がいません。
     - その後、前任者がコードを削除する際、誤ってそれも一緒に削除してしまい（前任者はGitの使い方を知らないため使用しないため、本当になくなりました）、今は本当に私も自分の業績を証明できません。それだけを考えると、夜に眠れません。
   - モノレポルートにESLintとPrettier、および私が直接作成したプラグイン（強制的にUTF-8エンコーディング変換、CRLFを強制的にLFに変換など）を設定しました。
3. 生産性を向上させました。
   - デザインシステムを作成しました。これは後で別途説明します。
