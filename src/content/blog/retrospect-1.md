---
title: '신입사원의 회고'
description: '프론트 1년차, 우리 제품을 위해 이룬것과 앞으로 해야 할 것들.'
pubDate: 'Nov 9 2024'
heroImage: '../../assets/images/yonghyun-lee-unsplash.jpg'
category: 'Frontend'
tags: ['Career', 'Retrospect', 'Improvement']
---

# 배경

내 시작은 백엔드 개발자였다. 남들 많이 하는 Java Spring 백엔드 개발 공부했다.

Video Management System을 만드는 부서에 들어갔다. 주 언어는 C++이고 자체 개발 라이브러리를 사용한다고 했다. 1주일 정도 지나서 개인 면담을 진행했다. 우리 회사에 어떻게 오게 되었냐, 대학교
때 뭐 했냐, 어떤 언어로 개발할 수 있냐 여러 이야기를 나눈 후 미묘한 표정으로 회의실을 나섰다. 당시에 옆 부서에서 Node.js로 프록시 서버를 개발했던 사례가 있었다, Node.js는 할줄 아냐고 묻길래 할 줄 안다고 했다. 그렇게 수습기간동안 Node.js 백엔드 파일럿 프로젝트를 개발하게 되었다.

우리 팀이 만드는 제품은 웹과 전혀 관련이 없었다. 그래도 앞으로는 우리 제품에 웹을 도입할거라고 했다. 그래서 웹 개발자가 존재하고, '그들'이 웹 프론트엔드 개발자들이라고 했다. 그러나 수습기간 끝날때쯤...

> '그들'은 퇴사했고 그렇게 난 프론트엔드 개발자가 되었다

'그들' 중 막내에게 인수인계를 받았고 인수인계를 받으며 프론트 개발의 전반에 대해 이야기해볼 기회가 생겼다. 이야기를 듣고 결심했다.

> 퇴직금은 1년차에 나오니까 1년뒤에 퇴사하자

알고보니 '그들'은 초짜였다. 내 보스는 웹 개발쪽으로 딱히 터치를 하지 않다보니 '그들'이 우리 제품, 웹의 가치와 생산성 그리고 가능성 그 모든 미래를 실시간으로 망치고 있는 중이었다. 개선하지 못한 모든 것들에
대한 내 질문에 '그들'은 항상 개발자답지못한 변명으로 넘어갔고 내 보스는 "웹은 원래 그렇겠지" 하고 넘어갔다. 결국 **웹에서 해결해야 할 문제를 클라이언트와 서버의 성능 개선으로 틀어막고** 있었다.

# 개선하고자 했던 이유

'그들'과 대화한 후 깨달았다, 후술할 이유를 지금 설명하긴 어렵지만 확실한건, **우리 기존 제품 물론 훌륭해 하지만 웹 UI로써 가치, 발전가능성 그리고 미래 없어요**. 우리 팀에 그 누구도 그 사실을
몰랐지만 나는 알고 있었다.

솔직히 말해 그 당시 1년차 퇴직금받고 나가기로 결심했고 '그들'의 심기를 거스르지 않은 체 1년 때우다가 나갈 수도 있었다. 그때, Clean Code 책에 한 문구가 기억났다.

> **Always leave the campground cleaner than you found it**

1년 뒤에 퇴사 할지라도, 이 캠핑장에 똥통과 요강이 굴러다니는 채로 방치한다면 이후에 그 캠핑장을 사용하려 찾아온 사람들은 무슨 생각을 가질까? 성숙한 개발자라면 어떻게 행동할지 잠시 고민한 후 **이건 이제 내 문제야. 나의 문제는 내가 고친다**

# 문제 인식

'그들'은 우리 제품의 웹 개발의 기반이 되는 자체 프레임워크를 개발하는 업무를 진행했었다. '그들'이 만든 프레임워크로 개발했다던 웹 사이트 열어보았다. 페이지가 1개밖에 없는 프로젝트는 페이지가 뜰 때까지 10초 정도, 페이지 개수가 3~4개로 좀 되는 프로젝트는 첫 페이지가 뜰 때까지 30초 정도 걸렸다.

자사 클라이언트 캐싱 성능 개선으로 틀어막았는지(추측) 자사 클라이언트로 웹 사이트를 열면 1초 이내에 열린다, 그래서 이 문제를 지적했을 때 나만 이상한 놈 됐다. 아무도 문제라고 생각하지 않지만 이건 문제가 맞다. 더군다나 웹 UI가 자사 클라이언트 의존성을 벗어나야 한다는 보스의 말도 있었다.

1. 불필요한 Static File 요청을 서버에게 수백개 날리고 있다. 근데 그 중에 사용되는 파일은 몇개 없다.
2. static file 요청이 너무 많아서 트래픽이 한명만 붙어도 웹서버가 일부 파일에 대해 응답을 안한다.
3. 예외 처리가 없기 때문에 런타임 에러 발생시 전체 WebApp이 중단된다. If 분기처리로 Case-By-Case 처리하는 건 한계가 있고 그 Context를 '그들'만 안다.
4. 동적으로 만들어지는 모든 Node와 하위의 HTMLElement가 소멸하지 않는데 Heap Memory를 계속 차지하고 있다.
5. 이벤트 리스너가 사라지지 않고 누적만 된다. 그래서 몇 분동안 검색, 초기화 등 상호작용하다 보면 뭐 하나 클릭해도 수백개의 이벤트가 Bubble되고 있었다.

현대의 브라우저 성능이 뛰어나서 이따위로 짜도 수백개의 이벤트를 비동기적으로 처리하며, 그나마 버벅이는 데에서 그친 것인데 '그들'은 웹은 원래 성능 나빠요~했을 것이고 내 보스는 그 말 듣고 "브라우저 성능 구려 내지는 Javascript 구려"라는 편견이 생겨버린 듯 하다(추측). JS 싱글 스레드 맞지만 그걸 실행하는 브라우저는 싱글 스레드 아니에요, 최신 브라우저 성능 그리 나쁘지 않아요. 우리 JS 나쁜 아이 아니에요. '그들'의 가스라이팅 듣지 말아요.

# 기존의 해결방식

> 모든 내용은 픽션이며 실제 존재하는 서비스와는 관계없습니다.

1. 웹 서버의 성능을 개선하여 실제로 사용되지 않는 JS 파일 수백개 수천개를 요청해도 거뜬히 감당할 수 있게 만들어달라고 서버 개발자에게 부탁하기
2. 응답을 안하내? 똑같은 파일을 여러번 요청하게 DOM을 반복적으로 조작하기
3. 런타임 에러가 발생할 만한 모든 상황에 Case-By-Case로 IF 분기처리하고 Error가 발생하는 조건이면 빈 String을 반환하기
4. 답답하면 새로고침하기
5. 자사 클라이언트 개발자에게 안된다고 제보하고 자사 클라이언트 로직에서 이벤트가 너무 많이 Bubble되면 무시하도록 방어로직 짜줬다.

이것 말고도 기가막힌 솔루션이 많았는데 특히, const로 변수를 선언하지 않는 이유. 2번과 관련되어있는데 const로 변수 선언하면 에러나니까 이 파일과 저파일 그리고 이 파일에서는 const를 쓰지 마세요 이러길래 퇴사가 마려웠다.

# 근본적인 원인

> 모든 내용은 픽션이며 실제 존재하는 서비스와는 관계없다고 믿고 싶습니다.

'그들'이 저지른 범죄들은 다음과 같다.

1. 간단히 요약하면
   1. 표준을 안쓴다, 자신만 아는 규칙으로 자신만 아는 메서드를 특정 파일에 몰래 숨겨놓았다가 런타임에 삽입한다.
   2. 그 규칙과 함수는 자신이 퇴사하면 아무도 못찾도록 IDE가 인식 못하도록 만든다(몽키패칭과 자체정의한 Event 클래스, JS 문법 곧 죽어도 따르지 말고 모든 라인에 빨간줄 긋기).
2. 모든 변수와 함수가 전역에 선언되어 있다.
   1. 근데 그게 대부분 `let` 또는 `var`으로 선언이 되어있다.
   2. `foo(); get(); set(); getset() setget();`이런 식으로 일반적인 네이밍의 함수가 각각 오천만개씩 정의되어있다. 모두 전역에 선언했으므로 그 중 어떤 함수가 언제 실행 될지는 '그들'만 알고 있다.
   3. 같은 파일을 2~3번 서버에게 요청한 후 실행해버리는 특성 탓에 어떤 파일은 모든 변수가 `const`로 선언을 하면 안된다. 어떤 파일이 그런지는 '그들'만 알고 있다.
3. 충격과 공포의 Event 핸들링
   1. 일단 Javascript의 Event 클래스 사용하지 않는다. 자체 정의한 Event이므로 수천수만개 던져도 Browser는 인식을 못한다. 놀랍게도 React가 재랜더링을 하는 방식을 흉내내기 위해 노력했다.
   2. 후술하겠지만 당연히 대실패했고 이벤트 핸들러와 HTMLElement는 생성만되고 소멸이 되지 않는다.
   3. 놀랍게도 자체 정의 Event 클래스는 ClassName을 이용해서 Catch를 하고 있었고 당연히 ClassName은 유일하지 않기 때문에 지만 아는 ClassName 규칙을 만들어서 지만 아는 방법으로 Event를 전파한다.
   4. Event 처리하는 메서드는 또 Prototype이용한 Monkey Patching을 이용해서 구현한다. 따라서 모든 파일이 신뢰할 수 없으며 내가 이 이벤트를 처리하는 메서드를 `Ctrl + 좌클릭` 하면 아무것도 안뜨는데 분명 어딘가에서 Monkey Patching해서 지만 아는 방법으로 처리하고 있기 때문에 항상 모든 파일을 전수조사해야 한다.
4. CSS와 Javascript 코드를 import하기 위해 특정 함수로 런타임 중 index.html에 script 태그를 삽입한다.
   1. script태그때문에 반응이 느려질까봐 비동기로 가져오겠다고 의도를 한 것 까지는 OK. 솔직히 비동기 개념을 '그들'이 알고 있다는 점에서 감동받았다. 이 점은 높이 산다(근데 왜 로딩에 30초
      걸리냐? 라는 나쁜말은 하지마세요, '그들'은 최선을 다하셨잖아).
   2. 근데 그걸 초기화 과정이 아니라 각 스크립트 파일에 산포해 있고 그 기준이 존재하지 않아서 어떤 스크립트에는 있고 어떤 스크립트에는 없다.
   3. 그래서 기능 동작 중에 script 태그 붙이다가 이미 선언된 변수와 이름이 겹쳤을 때 기존에 의도한 동작이 아니라 다른 동작이 실행되거나 const로 인해서 런타임 에러가 발생하고
   4. '그들'은 '예외'라는 개념을 모르기 때문에 case by case로 일일히 if 분기처리하고 있다.
5. 네이밍은 중요하다, 허나 전체적으로 엉망이다. 예시는 다음과 같다.
   1. `include_js(), include_css()` '그들' 중 일부는 C언어 개발자셨는데 아마 그 분들께서 `#include <sth.h>`이걸 JS 버전으로 만든거라고 추측하고 있는 중이다. 일부 파일 중 헤더파일을 따라한 흔적이 있었기 때문.
   2. `strlen(), strcpy(), strcat()` '그들'은 javascript를 잘 몰랐나보다. 바이트 단위 조작으로 length구하고 copy하고 concat하는거 만드셨던데 그거 안만들어도 된다.
   3. 그 외, C의 stdio나 C++의 string 라이브러리와 동일한 네이밍의 수많은 전역함수들이 있었다. 그리고 역시, 필요없거나 잘못구현했으나 우연히 의도한 동작과 일치하는 함수들이었다.
   4. 메서드명으로 getSet, setGet, getFunc, getFoo 이러는데 솔직히 아직까지 업무중에 잠깐 꿈꿨겠지 하고 생각하고 있다. 니들 때문에 내 인식 속 C++ 개발자 평균 내려가서 가끔씩 당연한 것도 설명한다. 사과해라.
6. 모든 전역함수는 호출 직후 isValid(sth)를 호출하고 그 결과를 if 문으로 분기처리하고 있었다.
   1. 일단 Valid의 기준을 명확히 정의하지 않았다
   2. Array나 Map에 속하면 True를 반환한다.
   3. 문제는 Array가 아니라도 Valid한 파라미터인데 모든 전역함수에 대해 이 로직을 적용하고 있었다.
   4. 그래서 보스한테 꼰질렀는데 그 분은 isValid가 하도 많이 보이길래 Javascript의 기본 메서드라고 착각하고 있었다. 니들 나중에 보스 만나면 사과해라.
7. 모든 메서드가 Monkey Patching을 통해 만들어져있다, 모든 파일이 신뢰 불가능하다.
   1. '그들'은 컴포넌트라고 부르는, 일종의 코드의 뭉치를 가지고 있었는데 클래스를 좋아하는 그들은 Prototype Chaining과 몽키패칭, 그리고 ES6 Class 문법을 동시에 사용하고 있었다.
   2. 그리고 클래스의 모든 메서드는 Prototype 몽키 패칭으로 만들고 있었다.
   3. 특정 클래스의 메서드 사용법을 알기 위해 수많은 파일을 뒤져야 하며, 내가 보고 있는 이 메서드가 실존하는 메서드인지, 이 파일에서 몽키패칭한 메서드인지, 혹은 런타임에 덮어써지는 메서드인지 알 수 없다.
8. CSS 관리방식
   1. 버튼에 대한 CSS가 버튼 파일에 없다. jQuery와 DOM API를 동시에 사용하고 있었는데 버튼 CSS 조작을 Table과 관련된 파일에서 하고 Table CSS 조작을 index.js에서 한다.
   2. 일관되지 않은 방식: CSS-in-JS, CSS 파일, 동적인 Style태그 삽입 등 모든 방법을 총동원해서 CSS 관리 방식을 파편화시켰다.
9. 2012년 수준의 코드 스타일(**트랜드 안따라간다고 떽떽거리는거 아님**)
   1. 템플릿 리터럴 사용X, Prototype Chaining으로 class 사용, 4칸 공백 등등 OK 알겠어. 다 이해함, 상관없음.
   2. 코드 스타일에 일관성이 없다는게 문제다. ES6 문법을 쓰다말다 한다. 이게 무슨 말이냐면 Class 정의해놓고 메서드는 prototype으로 넣는다.
10. 번들링을 안함(그 자체가 문제는 아님)
    1. 번들링 안하는거 전혀 문제없음. 옛날에는 웹개발 다 그렇게 했다.
    2. 문제는 관리를 안한다는 것. 나는 lib라는 폴더가 있길래 거기다 다 몰아넣는 줄 알았는데 그게 아님. 지만 아는 특정 폴더에 멀웨어 마냥 숨겨놓는다.
    3. 예를 들어, `moment()`이건 moment.js라는 외부 라이브러리의 함수이다. 당연히 '그들'은 moment를 사용하기 위해 프로젝트 폴더 중 어딘가에 moment.js를 다운로드 받아서 넣어 둔 후, 수백개 파일 중 어느 곳에 `include_js('<path>')`를 넣었을 것이다. 근데 그걸 지만 알고 있다는게 문제다.
    4. 실제로 date time picker 라이브러리와 excel.js 라이브러리의 경우 그 라이브러리에서만 존재하는 메서드를 써놓고 그게 Javascript의 기본기능인줄 알고 있더라.
11. 패키지 매니저, 번들링, 빌드 없음. 웹 프레임워크를 각 프로젝트 폴더에다 통째로 `CTRL + C`, `CTRL + V` 로 사용함.
    1. 적어도 Grunt 같이 태스크 자동화 도구정도는 쓰자. 빌드 프로세스 이런거 안바란다. 적어도 웹 프레임워크를 각 폴더에다 통째로 복사를 할거면 그것정도는 자동화 할 수 있잖아.
    2. 안할거면 최소한 각 폴더마다 package.json에 **version** 명시라도 해야 하는데 각 프로젝트의 상태를 표현하는 무언가가 존재하지 않는다. Git이 뭔지 몰라? 패키지 매니저 뭔지 몰라? package.json 뭔지 몰라? 웹개발 안해봤어? OK 난 모두 이해할수 있어, 근데 최소한의 정보를 txt파일로라도 표기를 했어야지.
    3. 빌드 프로세스 자동화 안해서 각 프로젝트 마다 웹 프레임워크의 버전이 다르다. 한마디로 웹 프레임워크의 버전 관리를 안한다.
    4. 웹 프레임워크를 어떻게 가져오냐고 물어보니 그 용량 큰 폴더를 통째로 복사해서 쓰더라. 그럼 Production용으로 배포할 때는 어떻게 하냐고 물어보니 복붙하고 index.js 수정하래. 이러니까 실제 배포된 웹 페이지가 그 용량 큰 폴더의 모든 파일들을 부르게 되고 페이지 로딩에 10초가 걸리게 되었다.

### 삼체

위 항목 중에서 자신이 퇴사하면 아무도 메서드의 쓰임새를 못찾게 만들기 위해 모든 메서드를 몽키패칭하고 자체 정의한 Event와 자체 정의한 전파방식을 사용하여 IDE가 인식을 못하게 만든 것에서 내가 참 재미있게 본 Netflix 드라마 "삼체"가 생각났다.

"삼체"에서 "지자"라는 인공지능이 인류의 과학 발전을 막기 위해 대중에게 과학적인 연구 결과를 숨기고 기적만을 보여주는 공작활동을 한다.

"그들"은 지만 아는 규칙을 만들고 아무에게도 공유하지 않고, 모든 메서드를 숨기고, IDE 인식을 막고, JS문법 다 틀려서 모든 라인에 빨간줄그이게 만들어서 어쩔 수 없이 IDE의 syntax 기능 꺼버리게 만들고. "그들" 또한 개발자들의 논리적인 추론을 막고 "이게 돌아가네!" 기적만을 보여주어 개발자의 프론트엔드 기술 발전을 막기 위한 공작활동을 했다고 추측한다. 하지만 나는 굴하지 않았다.

삼체에서는 이야기가 어떻게 되더라? 파울은 면벽자가 되고 지자의 공작 활동을 이겨내어 끝내 인류가 살아남을 길을 모색했다.

> 다음 편 "달리는 자동차에서 엔진 교체하기"에서 계속...
